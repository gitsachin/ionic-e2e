"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic_core_dist_esm_ion-popover_entry_js"],{

/***/ 9459:
/*!****************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/ion-popover.entry.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_popover": function() { return /* binding */ Popover; }
/* harmony export */ });
/* harmony import */ var _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ 9341);
/* harmony import */ var _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck */ 5960);
/* harmony import */ var _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass */ 9367);
/* harmony import */ var _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ 2783);
/* harmony import */ var _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ 3703);
/* harmony import */ var _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-06cd27b1.js */ 7781);
/* harmony import */ var _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ionic-global-a049bcbf.js */ 8420);
/* harmony import */ var _framework_delegate_c972cd13_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./framework-delegate-c972cd13.js */ 5309);
/* harmony import */ var _helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers-6ff04165.js */ 7484);
/* harmony import */ var _overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./overlays-7135448f.js */ 2091);
/* harmony import */ var _theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./theme-a24ff1ad.js */ 7679);
/* harmony import */ var _index_2497e97d_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./index-2497e97d.js */ 3480);
/* harmony import */ var _animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./animation-7e9a7324.js */ 8158);
/* harmony import */ var _hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./hardware-back-button-ace6a71b.js */ 2170);






/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */









/**
 * Returns the dimensions of the popover
 * arrow on `ios` mode. If arrow is disabled
 * returns (0, 0).
 */

var getArrowDimensions = function getArrowDimensions(arrowEl) {
  if (!arrowEl) {
    return {
      arrowWidth: 0,
      arrowHeight: 0
    };
  }

  var _arrowEl$getBoundingC = arrowEl.getBoundingClientRect(),
      width = _arrowEl$getBoundingC.width,
      height = _arrowEl$getBoundingC.height;

  return {
    arrowWidth: width,
    arrowHeight: height
  };
};
/**
 * Returns the recommended dimensions of the popover
 * that takes into account whether or not the width
 * should match the trigger width.
 */


var getPopoverDimensions = function getPopoverDimensions(size, contentEl, triggerEl) {
  var contentDimentions = contentEl.getBoundingClientRect();
  var contentHeight = contentDimentions.height;
  var contentWidth = contentDimentions.width;

  if (size === 'cover' && triggerEl) {
    var triggerDimensions = triggerEl.getBoundingClientRect();
    contentWidth = triggerDimensions.width;
  }

  return {
    contentWidth: contentWidth,
    contentHeight: contentHeight
  };
};

var configureDismissInteraction = function configureDismissInteraction(triggerEl, triggerAction, popoverEl, parentPopoverEl) {
  var dismissCallbacks = [];
  var root = (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.g)(parentPopoverEl);
  var parentContentEl = root.querySelector('.popover-content');

  switch (triggerAction) {
    case 'hover':
      dismissCallbacks = [{
        /**
         * Do not use mouseover here
         * as this will causes the event to
         * be dispatched on each underlying
         * element rather than on the popover
         * content as a whole.
         */
        eventName: 'mouseenter',
        callback: function callback(ev) {
          /**
           * Do not dismiss the popover is we
           * are hovering over its trigger.
           * This would be easier if we used mouseover
           * but this would cause the event to be dispatched
           * more often than we would like, potentially
           * causing performance issues.
           */
          var element = document.elementFromPoint(ev.clientX, ev.clientY);

          if (element === triggerEl) {
            return;
          }

          popoverEl.dismiss(undefined, undefined, false);
        }
      }];
      break;

    case 'context-menu':
    case 'click':
    default:
      dismissCallbacks = [{
        eventName: 'click',
        callback: function callback(ev) {
          /**
           * Do not dismiss the popover is we
           * are hovering over its trigger.
           */
          var target = ev.target;
          var closestTrigger = target.closest('[data-ion-popover-trigger]');

          if (closestTrigger === triggerEl) {
            /**
             * stopPropagation here so if the
             * popover has dismissOnSelect="true"
             * the popover does not dismiss since
             * we just clicked a trigger element.
             */
            ev.stopPropagation();
            return;
          }

          popoverEl.dismiss(undefined, undefined, false);
        }
      }];
      break;
  }

  dismissCallbacks.forEach(function (_ref) {
    var eventName = _ref.eventName,
        callback = _ref.callback;
    return parentContentEl.addEventListener(eventName, callback);
  });
  return function () {
    dismissCallbacks.forEach(function (_ref2) {
      var eventName = _ref2.eventName,
          callback = _ref2.callback;
      return parentContentEl.removeEventListener(eventName, callback);
    });
  };
};
/**
 * Configures the triggerEl to respond
 * to user interaction based upon the triggerAction
 * prop that devs have defined.
 */


var configureTriggerInteraction = function configureTriggerInteraction(triggerEl, triggerAction, popoverEl) {
  var triggerCallbacks = [];
  /**
   * Based upon the kind of trigger interaction
   * the user wants, we setup the correct event
   * listeners.
   */

  switch (triggerAction) {
    case 'hover':
      var hoverTimeout;
      triggerCallbacks = [{
        eventName: 'mouseenter',
        callback: function () {
          var _callback = (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])( /*#__PURE__*/_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().mark(function _callee(ev) {
            return _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    ev.stopPropagation();

                    if (hoverTimeout) {
                      clearTimeout(hoverTimeout);
                    }
                    /**
                     * Hovering over a trigger should not
                     * immediately open the next popover.
                     */


                    hoverTimeout = setTimeout(function () {
                      (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.r)(function () {
                        popoverEl.presentFromTrigger(ev);
                        hoverTimeout = undefined;
                      });
                    }, 100);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function callback(_x) {
            return _callback.apply(this, arguments);
          }

          return callback;
        }()
      }, {
        eventName: 'mouseleave',
        callback: function callback(ev) {
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
          }
          /**
           * If mouse is over another popover
           * that is not this popover then we should
           * close this popover.
           */


          var target = ev.relatedTarget;

          if (!target) {
            return;
          }

          if (target.closest('ion-popover') !== popoverEl) {
            popoverEl.dismiss(undefined, undefined, false);
          }
        }
      }, {
        /**
         * stopPropagation here prevents the popover
         * from dismissing when dismiss-on-select="true".
         */
        eventName: 'click',
        callback: function callback(ev) {
          return ev.stopPropagation();
        }
      }, {
        eventName: 'ionPopoverActivateTrigger',
        callback: function callback(ev) {
          return popoverEl.presentFromTrigger(ev, true);
        }
      }];
      break;

    case 'context-menu':
      triggerCallbacks = [{
        eventName: 'contextmenu',
        callback: function callback(ev) {
          /**
           * Prevents the platform context
           * menu from appearing.
           */
          ev.preventDefault();
          popoverEl.presentFromTrigger(ev);
        }
      }, {
        eventName: 'click',
        callback: function callback(ev) {
          return ev.stopPropagation();
        }
      }, {
        eventName: 'ionPopoverActivateTrigger',
        callback: function callback(ev) {
          return popoverEl.presentFromTrigger(ev, true);
        }
      }];
      break;

    case 'click':
    default:
      triggerCallbacks = [{
        /**
         * Do not do a stopPropagation() here
         * because if you had two click triggers
         * then clicking the first trigger and then
         * clicking the second trigger would not cause
         * the first popover to dismiss.
         */
        eventName: 'click',
        callback: function callback(ev) {
          return popoverEl.presentFromTrigger(ev);
        }
      }, {
        eventName: 'ionPopoverActivateTrigger',
        callback: function callback(ev) {
          return popoverEl.presentFromTrigger(ev, true);
        }
      }];
      break;
  }

  triggerCallbacks.forEach(function (_ref3) {
    var eventName = _ref3.eventName,
        callback = _ref3.callback;
    return triggerEl.addEventListener(eventName, callback);
  });
  triggerEl.setAttribute('data-ion-popover-trigger', 'true');
  return function () {
    triggerCallbacks.forEach(function (_ref4) {
      var eventName = _ref4.eventName,
          callback = _ref4.callback;
      return triggerEl.removeEventListener(eventName, callback);
    });
    triggerEl.removeAttribute('data-ion-popover-trigger');
  };
};
/**
 * Returns the index of an ion-item in an array of ion-items.
 */


var getIndexOfItem = function getIndexOfItem(items, item) {
  if (!item || item.tagName !== 'ION-ITEM') {
    return -1;
  }

  return items.findIndex(function (el) {
    return el === item;
  });
};
/**
 * Given an array of elements and a currently focused ion-item
 * returns the next ion-item relative to the focused one or
 * undefined.
 */


var getNextItem = function getNextItem(items, currentItem) {
  var currentItemIndex = getIndexOfItem(items, currentItem);
  return items[currentItemIndex + 1];
};
/**
 * Given an array of elements and a currently focused ion-item
 * returns the previous ion-item relative to the focused one or
 * undefined.
 */


var getPrevItem = function getPrevItem(items, currentItem) {
  var currentItemIndex = getIndexOfItem(items, currentItem);
  return items[currentItemIndex - 1];
};
/** Focus the internal button of the ion-item */


var focusItem = function focusItem(item) {
  var root = (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.g)(item);
  var button = root.querySelector('button');

  if (button) {
    (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.r)(function () {
      return button.focus();
    });
  }
};
/**
 * Returns `true` if `el` has been designated
 * as a trigger element for an ion-popover.
 */


var isTriggerElement = function isTriggerElement(el) {
  return el.hasAttribute('data-ion-popover-trigger');
};

var configureKeyboardInteraction = function configureKeyboardInteraction(popoverEl) {
  var callback = /*#__PURE__*/function () {
    var _ref5 = (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])( /*#__PURE__*/_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().mark(function _callee2(ev) {
      var activeElement, items, parentPopover, nextItem, prevItem, firstItem, lastItem, rightEvent;
      return _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              activeElement = document.activeElement;
              items = [];
              /**
               * Complex selectors with :not() are :not supported
               * in older versions of Chromium so we need to do a
               * try/catch here so errors are not thrown.
               */

              try {
                /**
                 * Select all ion-items that are not children of child popovers.
                 * i.e. only select ion-item elements that are part of this popover
                 */
                items = Array.from(popoverEl.querySelectorAll('ion-item:not(ion-popover ion-popover *):not([disabled])'));
                /* tslint:disable-next-line */
              } catch (_a) {}

              _context2.t0 = ev.key;
              _context2.next = _context2.t0 === 'ArrowLeft' ? 6 : _context2.t0 === 'ArrowDown' ? 11 : _context2.t0 === 'ArrowUp' ? 15 : _context2.t0 === 'Home' ? 19 : _context2.t0 === 'End' ? 23 : _context2.t0 === 'ArrowRight' ? 27 : _context2.t0 === ' ' ? 27 : _context2.t0 === 'Enter' ? 27 : 29;
              break;

            case 6:
              _context2.next = 8;
              return popoverEl.getParentPopover();

            case 8:
              parentPopover = _context2.sent;

              if (parentPopover) {
                popoverEl.dismiss(undefined, undefined, false);
              }

              return _context2.abrupt("break", 29);

            case 11:
              ev.preventDefault();
              nextItem = getNextItem(items, activeElement); // tslint:disable-next-line:strict-type-predicates

              if (nextItem !== undefined) {
                focusItem(nextItem);
              }

              return _context2.abrupt("break", 29);

            case 15:
              ev.preventDefault();
              prevItem = getPrevItem(items, activeElement); // tslint:disable-next-line:strict-type-predicates

              if (prevItem !== undefined) {
                focusItem(prevItem);
              }

              return _context2.abrupt("break", 29);

            case 19:
              ev.preventDefault();
              firstItem = items[0]; // tslint:disable-next-line:strict-type-predicates

              if (firstItem !== undefined) {
                focusItem(firstItem);
              }

              return _context2.abrupt("break", 29);

            case 23:
              ev.preventDefault();
              lastItem = items[items.length - 1]; // tslint:disable-next-line:strict-type-predicates

              if (lastItem !== undefined) {
                focusItem(lastItem);
              }

              return _context2.abrupt("break", 29);

            case 27:
              if (activeElement && isTriggerElement(activeElement)) {
                rightEvent = new CustomEvent('ionPopoverActivateTrigger');
                activeElement.dispatchEvent(rightEvent);
              }

              return _context2.abrupt("break", 29);

            case 29:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function callback(_x2) {
      return _ref5.apply(this, arguments);
    };
  }();

  popoverEl.addEventListener('keydown', callback);
  return function () {
    return popoverEl.removeEventListener('keydown', callback);
  };
};
/**
 * Positions a popover by taking into account
 * the reference point, preferred side, alignment
 * and viewport dimensions.
 */


var getPopoverPosition = function getPopoverPosition(isRTL, contentWidth, contentHeight, arrowWidth, arrowHeight, reference, side, align, defaultPosition, triggerEl, event) {
  var _a;

  var referenceCoordinates = {
    top: 0,
    left: 0,
    width: 0,
    height: 0
  };
  /**
   * Calculate position relative to the
   * x-y coordinates in the event that
   * was passed in
   */

  switch (reference) {
    case 'event':
      if (!event) {
        return defaultPosition;
      }

      var mouseEv = event;
      referenceCoordinates = {
        top: mouseEv.clientY,
        left: mouseEv.clientX,
        width: 1,
        height: 1
      };
      break;

    /**
     * Calculate position relative to the bounding
     * box on either the trigger element
     * specified via the `trigger` prop or
     * the target specified on the event
     * that was passed in.
     */

    case 'trigger':
    default:
      var customEv = event;
      /**
       * ionShadowTarget is used when we need to align the
       * popover with an element inside of the shadow root
       * of an Ionic component. Ex: Presenting a popover
       * by clicking on the collapsed indicator inside
       * of `ion-breadcrumb` and centering it relative
       * to the indicator rather than `ion-breadcrumb`
       * as a whole.
       */

      var actualTriggerEl = triggerEl || ((_a = customEv === null || customEv === void 0 ? void 0 : customEv.detail) === null || _a === void 0 ? void 0 : _a.ionShadowTarget) || (customEv === null || customEv === void 0 ? void 0 : customEv.target);

      if (!actualTriggerEl) {
        return defaultPosition;
      }

      var triggerBoundingBox = actualTriggerEl.getBoundingClientRect();
      referenceCoordinates = {
        top: triggerBoundingBox.top,
        left: triggerBoundingBox.left,
        width: triggerBoundingBox.width,
        height: triggerBoundingBox.height
      };
      break;
  }
  /**
   * Get top/left offset that would allow
   * popover to be positioned on the
   * preferred side of the reference.
   */


  var coordinates = calculatePopoverSide(side, referenceCoordinates, contentWidth, contentHeight, arrowWidth, arrowHeight, isRTL);
  /**
   * Get the top/left adjustments that
   * would allow the popover content
   * to have the correct alignment.
   */

  var alignedCoordinates = calculatePopoverAlign(align, side, referenceCoordinates, contentWidth, contentHeight);
  var top = coordinates.top + alignedCoordinates.top;
  var left = coordinates.left + alignedCoordinates.left;

  var _calculateArrowPositi = calculateArrowPosition(side, arrowWidth, arrowHeight, top, left, contentWidth, contentHeight, isRTL),
      arrowTop = _calculateArrowPositi.arrowTop,
      arrowLeft = _calculateArrowPositi.arrowLeft;

  var _calculatePopoverOrig = calculatePopoverOrigin(side, align, isRTL),
      originX = _calculatePopoverOrig.originX,
      originY = _calculatePopoverOrig.originY;

  return {
    top: top,
    left: left,
    referenceCoordinates: referenceCoordinates,
    arrowTop: arrowTop,
    arrowLeft: arrowLeft,
    originX: originX,
    originY: originY
  };
};
/**
 * Determines the transform-origin
 * of the popover animation so that it
 * is in line with what the side and alignment
 * prop values are. Currently only used
 * with the MD animation.
 */


var calculatePopoverOrigin = function calculatePopoverOrigin(side, align, isRTL) {
  switch (side) {
    case 'top':
      return {
        originX: getOriginXAlignment(align),
        originY: 'bottom'
      };

    case 'bottom':
      return {
        originX: getOriginXAlignment(align),
        originY: 'top'
      };

    case 'left':
      return {
        originX: 'right',
        originY: getOriginYAlignment(align)
      };

    case 'right':
      return {
        originX: 'left',
        originY: getOriginYAlignment(align)
      };

    case 'start':
      return {
        originX: isRTL ? 'left' : 'right',
        originY: getOriginYAlignment(align)
      };

    case 'end':
      return {
        originX: isRTL ? 'right' : 'left',
        originY: getOriginYAlignment(align)
      };
  }
};

var getOriginXAlignment = function getOriginXAlignment(align) {
  switch (align) {
    case 'start':
      return 'left';

    case 'center':
      return 'center';

    case 'end':
      return 'right';
  }
};

var getOriginYAlignment = function getOriginYAlignment(align) {
  switch (align) {
    case 'start':
      return 'top';

    case 'center':
      return 'center';

    case 'end':
      return 'bottom';
  }
};
/**
 * Calculates where the arrow positioning
 * should be relative to the popover content.
 */


var calculateArrowPosition = function calculateArrowPosition(side, arrowWidth, arrowHeight, top, left, contentWidth, contentHeight, isRTL) {
  /**
   * Note: When side is left, right, start, or end, the arrow is
   * been rotated using a `transform`, so to move the arrow up or down
   * by its dimension, you need to use `arrowWidth`.
   */
  var leftPosition = {
    arrowTop: top + contentHeight / 2 - arrowWidth / 2,
    arrowLeft: left + contentWidth - arrowWidth / 2
  };
  /**
   * Move the arrow to the left by arrowWidth and then
   * again by half of its width because we have rotated
   * the arrow using a transform.
   */

  var rightPosition = {
    arrowTop: top + contentHeight / 2 - arrowWidth / 2,
    arrowLeft: left - arrowWidth * 1.5
  };

  switch (side) {
    case 'top':
      return {
        arrowTop: top + contentHeight,
        arrowLeft: left + contentWidth / 2 - arrowWidth / 2
      };

    case 'bottom':
      return {
        arrowTop: top - arrowHeight,
        arrowLeft: left + contentWidth / 2 - arrowWidth / 2
      };

    case 'left':
      return leftPosition;

    case 'right':
      return rightPosition;

    case 'start':
      return isRTL ? rightPosition : leftPosition;

    case 'end':
      return isRTL ? leftPosition : rightPosition;

    default:
      return {
        arrowTop: 0,
        arrowLeft: 0
      };
  }
};
/**
 * Calculates the required top/left
 * values needed to position the popover
 * content on the side specified in the
 * `side` prop.
 */


var calculatePopoverSide = function calculatePopoverSide(side, triggerBoundingBox, contentWidth, contentHeight, arrowWidth, arrowHeight, isRTL) {
  var sideLeft = {
    top: triggerBoundingBox.top,
    left: triggerBoundingBox.left - contentWidth - arrowWidth
  };
  var sideRight = {
    top: triggerBoundingBox.top,
    left: triggerBoundingBox.left + triggerBoundingBox.width + arrowWidth
  };

  switch (side) {
    case 'top':
      return {
        top: triggerBoundingBox.top - contentHeight - arrowHeight,
        left: triggerBoundingBox.left
      };

    case 'right':
      return sideRight;

    case 'bottom':
      return {
        top: triggerBoundingBox.top + triggerBoundingBox.height + arrowHeight,
        left: triggerBoundingBox.left
      };

    case 'left':
      return sideLeft;

    case 'start':
      return isRTL ? sideRight : sideLeft;

    case 'end':
      return isRTL ? sideLeft : sideRight;
  }
};
/**
 * Calculates the required top/left
 * offset values needed to provide the
 * correct alignment regardless while taking
 * into account the side the popover is on.
 */


var calculatePopoverAlign = function calculatePopoverAlign(align, side, triggerBoundingBox, contentWidth, contentHeight) {
  switch (align) {
    case 'center':
      return calculatePopoverCenterAlign(side, triggerBoundingBox, contentWidth, contentHeight);

    case 'end':
      return calculatePopoverEndAlign(side, triggerBoundingBox, contentWidth, contentHeight);

    case 'start':
    default:
      return {
        top: 0,
        left: 0
      };
  }
};
/**
 * Calculate the end alignment for
 * the popover. If side is on the x-axis
 * then the align values refer to the top
 * and bottom margins of the content.
 * If side is on the y-axis then the
 * align values refer to the left and right
 * margins of the content.
 */


var calculatePopoverEndAlign = function calculatePopoverEndAlign(side, triggerBoundingBox, contentWidth, contentHeight) {
  switch (side) {
    case 'start':
    case 'end':
    case 'left':
    case 'right':
      return {
        top: -(contentHeight - triggerBoundingBox.height),
        left: 0
      };

    case 'top':
    case 'bottom':
    default:
      return {
        top: 0,
        left: -(contentWidth - triggerBoundingBox.width)
      };
  }
};
/**
 * Calculate the center alignment for
 * the popover. If side is on the x-axis
 * then the align values refer to the top
 * and bottom margins of the content.
 * If side is on the y-axis then the
 * align values refer to the left and right
 * margins of the content.
 */


var calculatePopoverCenterAlign = function calculatePopoverCenterAlign(side, triggerBoundingBox, contentWidth, contentHeight) {
  switch (side) {
    case 'start':
    case 'end':
    case 'left':
    case 'right':
      return {
        top: -(contentHeight / 2 - triggerBoundingBox.height / 2),
        left: 0
      };

    case 'top':
    case 'bottom':
    default:
      return {
        top: 0,
        left: -(contentWidth / 2 - triggerBoundingBox.width / 2)
      };
  }
};
/**
 * Adjusts popover positioning coordinates
 * such that popover does not appear offscreen
 * or overlapping safe area bounds.
 */


var calculateWindowAdjustment = function calculateWindowAdjustment(side, coordTop, coordLeft, bodyPadding, bodyWidth, bodyHeight, contentWidth, contentHeight, safeAreaMargin, contentOriginX, contentOriginY, triggerCoordinates) {
  var coordArrowTop = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
  var coordArrowLeft = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
  var arrowHeight = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
  var arrowTop = coordArrowTop;
  var arrowLeft = coordArrowLeft;
  var left = coordLeft;
  var top = coordTop;
  var bottom;
  var originX = contentOriginX;
  var originY = contentOriginY;
  var checkSafeAreaLeft = false;
  var checkSafeAreaRight = false;
  var triggerTop = triggerCoordinates ? triggerCoordinates.top + triggerCoordinates.height : bodyHeight / 2 - contentHeight / 2;
  var triggerHeight = triggerCoordinates ? triggerCoordinates.height : 0;
  var addPopoverBottomClass = false;
  /**
   * Adjust popover so it does not
   * go off the left of the screen.
   */

  if (left < bodyPadding + safeAreaMargin) {
    left = bodyPadding;
    checkSafeAreaLeft = true;
    originX = 'left';
    /**
     * Adjust popover so it does not
     * go off the right of the screen.
     */
  } else if (contentWidth + bodyPadding + left + safeAreaMargin > bodyWidth) {
    checkSafeAreaRight = true;
    left = bodyWidth - contentWidth - bodyPadding;
    originX = 'right';
  }
  /**
   * Adjust popover so it does not
   * go off the top of the screen.
   * If popover is on the left or the right of
   * the trigger, then we should not adjust top
   * margins.
   */


  if (triggerTop + triggerHeight + contentHeight > bodyHeight && (side === 'top' || side === 'bottom')) {
    if (triggerTop - contentHeight > 0) {
      top = triggerTop - contentHeight - triggerHeight - (arrowHeight - 1);
      arrowTop = top + contentHeight;
      originY = 'bottom';
      addPopoverBottomClass = true;
      /**
       * If not enough room for popover to appear
       * above trigger, then cut it off.
       */
    } else {
      bottom = bodyPadding;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    originX: originX,
    originY: originY,
    checkSafeAreaLeft: checkSafeAreaLeft,
    checkSafeAreaRight: checkSafeAreaRight,
    arrowTop: arrowTop,
    arrowLeft: arrowLeft,
    addPopoverBottomClass: addPopoverBottomClass
  };
};

var shouldShowArrow = function shouldShowArrow(side) {
  var didAdjustBounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var ev = arguments.length > 2 ? arguments[2] : undefined;
  var trigger = arguments.length > 3 ? arguments[3] : undefined;

  /**
   * If no event provided and
   * we do not have a trigger,
   * then this popover was likely
   * presented via the popoverController
   * or users called `present` manually.
   * In this case, the arrow should not be
   * shown as we do not have a reference.
   */
  if (!ev && !trigger) {
    return false;
  }
  /**
   * If popover is on the left or the right
   * of a trigger, but we needed to adjust the
   * popover due to screen bounds, then we should
   * hide the arrow as it will never be pointing
   * at the trigger.
   */


  if (side !== 'top' && side !== 'bottom' && didAdjustBounds) {
    return false;
  }

  return true;
};

var POPOVER_IOS_BODY_PADDING = 5;
/**
 * iOS Popover Enter Animation
 */

var iosEnterAnimation = function iosEnterAnimation(baseEl, opts) {
  var _a;

  var ev = opts.event,
      size = opts.size,
      trigger = opts.trigger,
      reference = opts.reference,
      side = opts.side,
      align = opts.align;
  var doc = baseEl.ownerDocument;
  var isRTL = doc.dir === 'rtl';
  var bodyWidth = doc.defaultView.innerWidth;
  var bodyHeight = doc.defaultView.innerHeight;
  var root = (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.g)(baseEl);
  var contentEl = root.querySelector('.popover-content');
  var arrowEl = root.querySelector('.popover-arrow');
  var referenceSizeEl = trigger || ((_a = ev === null || ev === void 0 ? void 0 : ev.detail) === null || _a === void 0 ? void 0 : _a.ionShadowTarget) || (ev === null || ev === void 0 ? void 0 : ev.target);

  var _getPopoverDimensions = getPopoverDimensions(size, contentEl, referenceSizeEl),
      contentWidth = _getPopoverDimensions.contentWidth,
      contentHeight = _getPopoverDimensions.contentHeight;

  var _getArrowDimensions = getArrowDimensions(arrowEl),
      arrowWidth = _getArrowDimensions.arrowWidth,
      arrowHeight = _getArrowDimensions.arrowHeight;

  var defaultPosition = {
    top: bodyHeight / 2 - contentHeight / 2,
    left: bodyWidth / 2 - contentWidth / 2,
    originX: isRTL ? 'right' : 'left',
    originY: 'top'
  };
  var results = getPopoverPosition(isRTL, contentWidth, contentHeight, arrowWidth, arrowHeight, reference, side, align, defaultPosition, trigger, ev);
  var padding = size === 'cover' ? 0 : POPOVER_IOS_BODY_PADDING;
  var margin = size === 'cover' ? 0 : 25;

  var _calculateWindowAdjus = calculateWindowAdjustment(side, results.top, results.left, padding, bodyWidth, bodyHeight, contentWidth, contentHeight, margin, results.originX, results.originY, results.referenceCoordinates, results.arrowTop, results.arrowLeft, arrowHeight),
      originX = _calculateWindowAdjus.originX,
      originY = _calculateWindowAdjus.originY,
      top = _calculateWindowAdjus.top,
      left = _calculateWindowAdjus.left,
      bottom = _calculateWindowAdjus.bottom,
      checkSafeAreaLeft = _calculateWindowAdjus.checkSafeAreaLeft,
      checkSafeAreaRight = _calculateWindowAdjus.checkSafeAreaRight,
      arrowTop = _calculateWindowAdjus.arrowTop,
      arrowLeft = _calculateWindowAdjus.arrowLeft,
      addPopoverBottomClass = _calculateWindowAdjus.addPopoverBottomClass;

  var baseAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var backdropAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var wrapperAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({
    'pointer-events': 'none'
  }).afterClearStyles(['pointer-events']);
  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).fromTo('opacity', 0.01, 1);
  return baseAnimation.easing('ease').duration(100).beforeAddWrite(function () {
    if (size === 'cover') {
      baseEl.style.setProperty('--width', "".concat(contentWidth, "px"));
    }

    if (addPopoverBottomClass) {
      baseEl.classList.add('popover-bottom');
    }

    if (bottom !== undefined) {
      contentEl.style.setProperty('bottom', "".concat(bottom, "px"));
    }

    var safeAreaLeft = ' + var(--ion-safe-area-left, 0)';
    var safeAreaRight = ' - var(--ion-safe-area-right, 0)';
    var leftValue = "".concat(left, "px");

    if (checkSafeAreaLeft) {
      leftValue = "".concat(left, "px").concat(safeAreaLeft);
    }

    if (checkSafeAreaRight) {
      leftValue = "".concat(left, "px").concat(safeAreaRight);
    }

    contentEl.style.setProperty('top', "calc(".concat(top, "px + var(--offset-y, 0))"));
    contentEl.style.setProperty('left', "calc(".concat(leftValue, " + var(--offset-x, 0))"));
    contentEl.style.setProperty('transform-origin', "".concat(originY, " ").concat(originX));

    if (arrowEl !== null) {
      var didAdjustBounds = results.top !== top || results.left !== left;
      var showArrow = shouldShowArrow(side, didAdjustBounds, ev, trigger);

      if (showArrow) {
        arrowEl.style.setProperty('top', "calc(".concat(arrowTop, "px + var(--offset-y, 0))"));
        arrowEl.style.setProperty('left', "calc(".concat(arrowLeft, "px + var(--offset-x, 0))"));
      } else {
        arrowEl.style.setProperty('display', 'none');
      }
    }
  }).addAnimation([backdropAnimation, wrapperAnimation]);
};
/**
 * iOS Popover Leave Animation
 */


var iosLeaveAnimation = function iosLeaveAnimation(baseEl) {
  var root = (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.g)(baseEl);
  var contentEl = root.querySelector('.popover-content');
  var arrowEl = root.querySelector('.popover-arrow');
  var baseAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var backdropAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var wrapperAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).fromTo('opacity', 0.99, 0);
  return baseAnimation.easing('ease').afterAddWrite(function () {
    baseEl.style.removeProperty('--width');
    baseEl.classList.remove('popover-bottom');
    contentEl.style.removeProperty('top');
    contentEl.style.removeProperty('left');
    contentEl.style.removeProperty('bottom');
    contentEl.style.removeProperty('transform-origin');

    if (arrowEl) {
      arrowEl.style.removeProperty('top');
      arrowEl.style.removeProperty('left');
      arrowEl.style.removeProperty('display');
    }
  }).duration(300).addAnimation([backdropAnimation, wrapperAnimation]);
};

var POPOVER_MD_BODY_PADDING = 12;
/**
 * Md Popover Enter Animation
 */

var mdEnterAnimation = function mdEnterAnimation(baseEl, opts) {
  var _a;

  var ev = opts.event,
      size = opts.size,
      trigger = opts.trigger,
      reference = opts.reference,
      side = opts.side,
      align = opts.align;
  var doc = baseEl.ownerDocument;
  var isRTL = doc.dir === 'rtl';
  var bodyWidth = doc.defaultView.innerWidth;
  var bodyHeight = doc.defaultView.innerHeight;
  var root = (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.g)(baseEl);
  var contentEl = root.querySelector('.popover-content');
  var referenceSizeEl = trigger || ((_a = ev === null || ev === void 0 ? void 0 : ev.detail) === null || _a === void 0 ? void 0 : _a.ionShadowTarget) || (ev === null || ev === void 0 ? void 0 : ev.target);

  var _getPopoverDimensions2 = getPopoverDimensions(size, contentEl, referenceSizeEl),
      contentWidth = _getPopoverDimensions2.contentWidth,
      contentHeight = _getPopoverDimensions2.contentHeight;

  var defaultPosition = {
    top: bodyHeight / 2 - contentHeight / 2,
    left: bodyWidth / 2 - contentWidth / 2,
    originX: isRTL ? 'right' : 'left',
    originY: 'top'
  };
  var results = getPopoverPosition(isRTL, contentWidth, contentHeight, 0, 0, reference, side, align, defaultPosition, trigger, ev);
  var padding = size === 'cover' ? 0 : POPOVER_MD_BODY_PADDING;

  var _calculateWindowAdjus2 = calculateWindowAdjustment(side, results.top, results.left, padding, bodyWidth, bodyHeight, contentWidth, contentHeight, 0, results.originX, results.originY, results.referenceCoordinates),
      originX = _calculateWindowAdjus2.originX,
      originY = _calculateWindowAdjus2.originY,
      top = _calculateWindowAdjus2.top,
      left = _calculateWindowAdjus2.left,
      bottom = _calculateWindowAdjus2.bottom;

  var baseAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var backdropAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var wrapperAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var contentAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var viewportAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({
    'pointer-events': 'none'
  }).afterClearStyles(['pointer-events']);
  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).duration(150).fromTo('opacity', 0.01, 1);
  contentAnimation.addElement(contentEl).beforeStyles({
    'top': "calc(".concat(top, "px + var(--offset-y, 0px))"),
    'left': "calc(".concat(left, "px + var(--offset-x, 0px))"),
    'transform-origin': "".concat(originY, " ").concat(originX)
  }).beforeAddWrite(function () {
    if (bottom !== undefined) {
      contentEl.style.setProperty('bottom', "".concat(bottom, "px"));
    }
  }).fromTo('transform', 'scale(0.8)', 'scale(1)');
  viewportAnimation.addElement(root.querySelector('.popover-viewport')).fromTo('opacity', 0.01, 1);
  return baseAnimation.easing('cubic-bezier(0.36,0.66,0.04,1)').duration(300).beforeAddWrite(function () {
    if (size === 'cover') {
      baseEl.style.setProperty('--width', "".concat(contentWidth, "px"));
    }

    if (originY === 'bottom') {
      baseEl.classList.add('popover-bottom');
    }
  }).addAnimation([backdropAnimation, wrapperAnimation, contentAnimation, viewportAnimation]);
};
/**
 * Md Popover Leave Animation
 */


var mdLeaveAnimation = function mdLeaveAnimation(baseEl) {
  var root = (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.g)(baseEl);
  var contentEl = root.querySelector('.popover-content');
  var baseAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var backdropAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  var wrapperAnimation = (0,_animation_7e9a7324_js__WEBPACK_IMPORTED_MODULE_12__.c)();
  backdropAnimation.addElement(root.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
  wrapperAnimation.addElement(root.querySelector('.popover-wrapper')).fromTo('opacity', 0.99, 0);
  return baseAnimation.easing('ease').afterAddWrite(function () {
    baseEl.style.removeProperty('--width');
    baseEl.classList.remove('popover-bottom');
    contentEl.style.removeProperty('top');
    contentEl.style.removeProperty('left');
    contentEl.style.removeProperty('bottom');
    contentEl.style.removeProperty('transform-origin');
  }).duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
};

var popoverIosCss = ":host{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;--offset-x:0px;--offset-y:0px;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001;pointer-events:none}:host(.popover-interactive) .popover-content,:host(.popover-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.popover-wrapper{opacity:0;z-index:10}.popover-content{display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px}:host(.popover-nested.popover-side-left){--offset-x:5px}:host(.popover-nested.popover-side-right){--offset-x:-5px}:host(.popover-nested.popover-side-start){--offset-x:5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-start),:host-context([dir=rtl]).popover-nested.popover-side-start{--offset-x:-5px}:host(.popover-nested.popover-side-end){--offset-x:-5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-end),:host-context([dir=rtl]).popover-nested.popover-side-end{--offset-x:5px}:host{--width:200px;--max-height:90%;--box-shadow:none;--backdrop-opacity:var(--ion-backdrop-opacity, 0.08)}:host(.popover-desktop){--box-shadow:0px 4px 16px 0px rgba(0, 0, 0, 0.12)}.popover-content{border-radius:10px}:host(.popover-desktop) .popover-content{border:0.5px solid var(--ion-color-step-100, #e6e6e6)}.popover-arrow{display:block;position:absolute;width:20px;height:10px;overflow:hidden}.popover-arrow::after{left:3px;top:3px;border-radius:3px;position:absolute;width:14px;height:14px;-webkit-transform:rotate(45deg);transform:rotate(45deg);background:var(--background);content:\"\";z-index:10}[dir=rtl] .popover-arrow::after,:host-context([dir=rtl]) .popover-arrow::after{left:unset;right:unset;right:3px}:host(.popover-bottom) .popover-arrow{top:auto;bottom:-10px}:host(.popover-bottom) .popover-arrow::after{top:-6px}:host(.popover-side-left) .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}:host(.popover-side-right) .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host(.popover-side-top) .popover-arrow{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host(.popover-side-start) .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}:host-context([dir=rtl]):host(.popover-side-start) .popover-arrow,:host-context([dir=rtl]).popover-side-start .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host(.popover-side-end) .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host-context([dir=rtl]):host(.popover-side-end) .popover-arrow,:host-context([dir=rtl]).popover-side-end .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.popover-translucent) .popover-content,:host(.popover-translucent) .popover-arrow::after{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}";
var popoverMdCss = ":host{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;--offset-x:0px;--offset-y:0px;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001;pointer-events:none}:host(.popover-interactive) .popover-content,:host(.popover-interactive) ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.popover-wrapper{opacity:0;z-index:10}.popover-content{display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px}:host(.popover-nested.popover-side-left){--offset-x:5px}:host(.popover-nested.popover-side-right){--offset-x:-5px}:host(.popover-nested.popover-side-start){--offset-x:5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-start),:host-context([dir=rtl]).popover-nested.popover-side-start{--offset-x:-5px}:host(.popover-nested.popover-side-end){--offset-x:-5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-end),:host-context([dir=rtl]).popover-nested.popover-side-end{--offset-x:5px}:host{--width:250px;--max-height:90%;--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}.popover-content{border-radius:4px;-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .popover-content,:host-context([dir=rtl]) .popover-content{-webkit-transform-origin:right top;transform-origin:right top}.popover-viewport{-webkit-transition-delay:100ms;transition-delay:100ms}";

var Popover = /*#__PURE__*/function () {
  function Popover(hostRef) {
    var _this = this;

    (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Popover);

    (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.r)(this, hostRef);
    this.didPresent = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionPopoverDidPresent", 7);
    this.willPresent = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionPopoverWillPresent", 7);
    this.willDismiss = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionPopoverWillDismiss", 7);
    this.didDismiss = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "ionPopoverDidDismiss", 7);
    this.didPresentShorthand = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "didPresent", 7);
    this.willPresentShorthand = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "willPresent", 7);
    this.willDismissShorthand = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "willDismiss", 7);
    this.didDismissShorthand = (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.e)(this, "didDismiss", 7);
    this.parentPopover = null;
    this.popoverIndex = popoverIds++;
    this.coreDelegate = (0,_framework_delegate_c972cd13_js__WEBPACK_IMPORTED_MODULE_7__.C)();
    this.inline = false;
    this.focusDescendantOnPresent = false;
    this.presented = false;
    /**
     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
     */

    this.keyboardClose = true;
    /**
     * If `true`, the popover will be dismissed when the backdrop is clicked.
     */

    this.backdropDismiss = true;
    /**
     * If `true`, a backdrop will be displayed behind the popover.
     */

    this.showBackdrop = true;
    /**
     * If `true`, the popover will be translucent.
     * Only applies when the mode is `"ios"` and the device supports
     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
     */

    this.translucent = false;
    /**
     * If `true`, the popover will animate.
     */

    this.animated = true;
    /**
     * Describes what kind of interaction with the trigger that
     * should cause the popover to open. Does not apply when the `trigger`
     * property is `undefined`.
     * If `'click'`, the popover will be presented when the trigger is left clicked.
     * If `'hover'`, the popover will be presented when a pointer hovers over the trigger.
     * If `'context-menu'`, the popover will be presented when the trigger is right
     * clicked on desktop and long pressed on mobile. This will also prevent your
     * device's normal context menu from appearing.
     */

    this.triggerAction = 'click';
    /**
     * Describes how to calculate the popover width.
     * If `'cover'`, the popover width will match the width of the trigger.
     * If `'auto'`, the popover width will be determined by the content in
     * the popover.
     */

    this.size = 'auto';
    /**
     * If `true`, the popover will be automatically
     * dismissed when the content has been clicked.
     */

    this.dismissOnSelect = false;
    /**
     * Describes what to position the popover relative to.
     * If `'trigger'`, the popover will be positioned relative
     * to the trigger button. If passing in an event, this is
     * determined via event.target.
     * If `'event'`, the popover will be positioned relative
     * to the x/y coordinates of the trigger action. If passing
     * in an event, this is determined via event.clientX and event.clientY.
     */

    this.reference = 'trigger';
    /**
     * Describes which side of the `reference` point to position
     * the popover on. The `'start'` and `'end'` values are RTL-aware,
     * and the `'left'` and `'right'` values are not.
     */

    this.side = 'bottom';
    /**
     * Describes how to align the popover content with the `reference` point.
     */

    this.alignment = 'start';
    /**
     * If `true`, the popover will display an arrow
     * that points at the `reference` when running in `ios` mode
     * on mobile. Does not apply in `md` mode or on desktop.
     */

    this.arrow = true;
    /**
     * If `true`, the popover will open. If `false`, the popover will close.
     * Use this if you need finer grained control over presentation, otherwise
     * just use the popoverController or the `trigger` property.
     * Note: `isOpen` will not automatically be set back to `false` when
     * the popover dismisses. You will need to do that in your code.
     */

    this.isOpen = false;

    this.onDismiss = function (ev) {
      ev.stopPropagation();
      ev.preventDefault();

      _this.dismiss();
    };

    this.onBackdropTap = function () {
      _this.dismiss(undefined, _overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__.B);
    };

    this.onLifecycle = function (modalEvent) {
      var el = _this.usersElement;
      var name = LIFECYCLE_MAP[modalEvent.type];

      if (el && name) {
        var event = new CustomEvent(name, {
          bubbles: false,
          cancelable: false,
          detail: modalEvent.detail
        });
        el.dispatchEvent(event);
      }
    };

    this.configureTriggerInteraction = function () {
      var trigger = _this.trigger,
          triggerAction = _this.triggerAction,
          el = _this.el,
          destroyTriggerInteraction = _this.destroyTriggerInteraction;

      if (destroyTriggerInteraction) {
        destroyTriggerInteraction();
      }

      var triggerEl = _this.triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;

      if (!triggerEl) {
        return;
      }

      _this.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, triggerAction, el);
    };

    this.configureKeyboardInteraction = function () {
      var destroyKeyboardInteraction = _this.destroyKeyboardInteraction,
          el = _this.el;

      if (destroyKeyboardInteraction) {
        destroyKeyboardInteraction();
      }

      _this.destroyKeyboardInteraction = configureKeyboardInteraction(el);
    };

    this.configureDismissInteraction = function () {
      var destroyDismissInteraction = _this.destroyDismissInteraction,
          parentPopover = _this.parentPopover,
          triggerAction = _this.triggerAction,
          triggerEl = _this.triggerEl,
          el = _this.el;

      if (!parentPopover || !triggerEl) {
        return;
      }

      if (destroyDismissInteraction) {
        destroyDismissInteraction();
      }

      _this.destroyDismissInteraction = configureDismissInteraction(triggerEl, triggerAction, el, parentPopover);
    };
  }

  (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(Popover, [{
    key: "onTriggerChange",
    value: function onTriggerChange() {
      this.configureTriggerInteraction();
    }
  }, {
    key: "onIsOpenChange",
    value: function onIsOpenChange(newValue, oldValue) {
      if (newValue === true && oldValue === false) {
        this.present();
      } else if (newValue === false && oldValue === true) {
        this.dismiss();
      }
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      (0,_overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__.e)(this.el);
    }
  }, {
    key: "componentWillLoad",
    value: function componentWillLoad() {
      /**
       * If user has custom ID set then we should
       * not assign the default incrementing ID.
       */
      this.popoverId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : "ion-popover-".concat(this.popoverIndex);
      this.parentPopover = this.el.closest("ion-popover:not(#".concat(this.popoverId, ")"));
    }
  }, {
    key: "componentDidLoad",
    value: function componentDidLoad() {
      var _this2 = this;

      var parentPopover = this.parentPopover,
          isOpen = this.isOpen;
      /**
       * If popover was rendered with isOpen="true"
       * then we should open popover immediately.
       */

      if (isOpen === true) {
        (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.r)(function () {
          return _this2.present();
        });
      }

      if (parentPopover) {
        (0,_helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_8__.a)(parentPopover, 'ionPopoverWillDismiss', function () {
          _this2.dismiss(undefined, undefined, false);
        });
      }

      this.configureTriggerInteraction();
    }
    /**
     * When opening a popover from a trigger, we should not be
     * modifying the `event` prop from inside the component.
     * Additionally, when pressing the "Right" arrow key, we need
     * to shift focus to the first descendant in the newly presented
     * popover.
     *
     * @internal
     */

  }, {
    key: "presentFromTrigger",
    value: function () {
      var _presentFromTrigger = (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])( /*#__PURE__*/_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().mark(function _callee3(event) {
        var focusDescendant,
            _args3 = arguments;
        return _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                focusDescendant = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;
                this.focusDescendantOnPresent = focusDescendant;
                _context3.next = 4;
                return this.present(event);

              case 4:
                this.focusDescendantOnPresent = false;

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function presentFromTrigger(_x3) {
        return _presentFromTrigger.apply(this, arguments);
      }

      return presentFromTrigger;
    }()
    /**
     * Determines whether or not an overlay
     * is being used inline or via a controller/JS
     * and returns the correct delegate.
     * By default, subsequent calls to getDelegate
     * will use a cached version of the delegate.
     * This is useful for calling dismiss after
     * present so that the correct delegate is given.
     */

  }, {
    key: "getDelegate",
    value: function getDelegate() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.workingDelegate && !force) {
        return {
          delegate: this.workingDelegate,
          inline: this.inline
        };
      }
      /**
       * If using overlay inline
       * we potentially need to use the coreDelegate
       * so that this works in vanilla JS apps.
       * If a user has already placed the overlay
       * as a direct descendant of ion-app or
       * the body, then we can assume that
       * the overlay is already in the correct place.
       */


      var parentEl = this.el.parentNode;
      var inline = this.inline = parentEl !== null && parentEl.tagName !== 'ION-APP' && parentEl.tagName !== 'BODY';
      var delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
      return {
        inline: inline,
        delegate: delegate
      };
    }
    /**
     * Present the popover overlay after it has been created.
     * Developers can pass a mouse, touch, or pointer event
     * to position the popover relative to where that event
     * was dispatched.
     */

  }, {
    key: "present",
    value: function () {
      var _present2 = (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])( /*#__PURE__*/_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().mark(function _callee4(event) {
        var data, _this$getDelegate, inline, delegate;

        return _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.presented) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return");

              case 2:
                if (!(this.currentTransition !== undefined)) {
                  _context4.next = 5;
                  break;
                }

                _context4.next = 5;
                return this.currentTransition;

              case 5:
                data = Object.assign(Object.assign({}, this.componentProps), {
                  popover: this.el
                });
                _this$getDelegate = this.getDelegate(true), inline = _this$getDelegate.inline, delegate = _this$getDelegate.delegate;
                _context4.next = 9;
                return (0,_framework_delegate_c972cd13_js__WEBPACK_IMPORTED_MODULE_7__.a)(delegate, this.el, this.component, ['popover-viewport'], data, inline);

              case 9:
                this.usersElement = _context4.sent;
                _context4.next = 12;
                return (0,_index_2497e97d_js__WEBPACK_IMPORTED_MODULE_11__.e)(this.usersElement);

              case 12:
                this.configureKeyboardInteraction();
                this.configureDismissInteraction();
                this.currentTransition = (0,_overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__.d)(this, 'popoverEnter', iosEnterAnimation, mdEnterAnimation, {
                  event: event || this.event,
                  size: this.size,
                  trigger: this.triggerEl,
                  reference: this.reference,
                  side: this.side,
                  align: this.alignment
                });
                _context4.next = 17;
                return this.currentTransition;

              case 17:
                this.currentTransition = undefined;
                /**
                 * If popover is nested and was
                 * presented using the "Right" arrow key,
                 * we need to move focus to the first
                 * descendant inside of the popover.
                 */

                if (this.focusDescendantOnPresent) {
                  (0,_overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__.j)(this.el, this.el);
                }

              case 19:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function present(_x4) {
        return _present2.apply(this, arguments);
      }

      return present;
    }()
    /**
     * Dismiss the popover overlay after it has been presented.
     *
     * @param data Any data to emit in the dismiss events.
     * @param role The role of the element that is dismissing the popover. For example, 'cancel' or 'backdrop'.
     * @param dismissParentPopover If `true`, dismissing this popover will also dismiss
     * a parent popover if this popover is nested. Defaults to `true`.
     */

  }, {
    key: "dismiss",
    value: function () {
      var _dismiss2 = (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])( /*#__PURE__*/_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().mark(function _callee5(data, role) {
        var dismissParentPopover,
            destroyKeyboardInteraction,
            destroyDismissInteraction,
            shouldDismiss,
            _this$getDelegate2,
            delegate,
            _args5 = arguments;

        return _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                dismissParentPopover = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : true;

                if (!(this.currentTransition !== undefined)) {
                  _context5.next = 4;
                  break;
                }

                _context5.next = 4;
                return this.currentTransition;

              case 4:
                destroyKeyboardInteraction = this.destroyKeyboardInteraction, destroyDismissInteraction = this.destroyDismissInteraction;

                if (dismissParentPopover && this.parentPopover) {
                  this.parentPopover.dismiss(data, role, dismissParentPopover);
                }

                this.currentTransition = (0,_overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__.f)(this, data, role, 'popoverLeave', iosLeaveAnimation, mdLeaveAnimation, this.event);
                _context5.next = 9;
                return this.currentTransition;

              case 9:
                shouldDismiss = _context5.sent;

                if (!shouldDismiss) {
                  _context5.next = 16;
                  break;
                }

                if (destroyKeyboardInteraction) {
                  destroyKeyboardInteraction();
                  this.destroyKeyboardInteraction = undefined;
                }

                if (destroyDismissInteraction) {
                  destroyDismissInteraction();
                  this.destroyDismissInteraction = undefined;
                }
                /**
                 * If using popover inline
                 * we potentially need to use the coreDelegate
                 * so that this works in vanilla JS apps
                 */


                _this$getDelegate2 = this.getDelegate(), delegate = _this$getDelegate2.delegate;
                _context5.next = 16;
                return (0,_framework_delegate_c972cd13_js__WEBPACK_IMPORTED_MODULE_7__.d)(delegate, this.usersElement);

              case 16:
                this.currentTransition = undefined;
                return _context5.abrupt("return", shouldDismiss);

              case 18:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function dismiss(_x5, _x6) {
        return _dismiss2.apply(this, arguments);
      }

      return dismiss;
    }()
    /**
     * @internal
     */

  }, {
    key: "getParentPopover",
    value: function () {
      var _getParentPopover = (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])( /*#__PURE__*/_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().mark(function _callee6() {
        return _home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_4___default().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.parentPopover);

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getParentPopover() {
        return _getParentPopover.apply(this, arguments);
      }

      return getParentPopover;
    }()
    /**
     * Returns a promise that resolves when the popover did dismiss.
     */

  }, {
    key: "onDidDismiss",
    value: function onDidDismiss() {
      return (0,_overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__.g)(this.el, 'ionPopoverDidDismiss');
    }
    /**
     * Returns a promise that resolves when the popover will dismiss.
     */

  }, {
    key: "onWillDismiss",
    value: function onWillDismiss() {
      return (0,_overlays_7135448f_js__WEBPACK_IMPORTED_MODULE_9__.g)(this.el, 'ionPopoverWillDismiss');
    }
  }, {
    key: "render",
    value: function render() {
      var _Object$assign,
          _this3 = this;

      var mode = (0,_ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_6__.b)(this);
      var onLifecycle = this.onLifecycle,
          popoverId = this.popoverId,
          parentPopover = this.parentPopover,
          dismissOnSelect = this.dismissOnSelect,
          presented = this.presented,
          side = this.side,
          arrow = this.arrow,
          htmlAttributes = this.htmlAttributes;
      var desktop = (0,_ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_6__.a)('desktop');
      var enableArrow = arrow && !parentPopover && !desktop;
      return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.h)(_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.H, Object.assign({
        "aria-modal": "true",
        "no-router": true,
        tabindex: "-1"
      }, htmlAttributes, {
        style: {
          zIndex: "".concat(20000 + this.overlayIndex)
        },
        id: popoverId,
        class: Object.assign(Object.assign({}, (0,_theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_10__.g)(this.cssClass)), (_Object$assign = {}, (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, mode, true), (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, 'popover-translucent', this.translucent), (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, 'overlay-hidden', true), (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, 'popover-interactive', presented), (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, 'popover-desktop', desktop), (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, "popover-side-".concat(side), true), (0,_home_runner_work_ionic_e2e_ionic_e2e_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_Object$assign, 'popover-nested', !!parentPopover), _Object$assign)),
        onIonPopoverDidPresent: onLifecycle,
        onIonPopoverWillPresent: onLifecycle,
        onIonPopoverWillDismiss: onLifecycle,
        onIonPopoverDidDismiss: onLifecycle,
        onIonDismiss: this.onDismiss,
        onIonBackdropTap: this.onBackdropTap
      }), !parentPopover && (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.h)("ion-backdrop", {
        tappable: this.backdropDismiss,
        visible: this.showBackdrop,
        part: "backdrop"
      }), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
        class: "popover-wrapper ion-overlay-wrapper",
        onClick: dismissOnSelect ? function () {
          return _this3.dismiss();
        } : undefined
      }, enableArrow && (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
        class: "popover-arrow",
        part: "arrow"
      }), (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
        class: "popover-content",
        part: "content"
      }, (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.h)("slot", null))));
    }
  }, {
    key: "el",
    get: function get() {
      return (0,_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_5__.i)(this);
    }
  }], [{
    key: "watchers",
    get: function get() {
      return {
        "trigger": ["onTriggerChange"],
        "triggerAction": ["onTriggerChange"],
        "isOpen": ["onIsOpenChange"]
      };
    }
  }]);

  return Popover;
}();

var LIFECYCLE_MAP = {
  'ionPopoverDidPresent': 'ionViewDidEnter',
  'ionPopoverWillPresent': 'ionViewWillEnter',
  'ionPopoverWillDismiss': 'ionViewWillLeave',
  'ionPopoverDidDismiss': 'ionViewDidLeave'
};
var popoverIds = 0;
Popover.style = {
  ios: popoverIosCss,
  md: popoverMdCss
};


/***/ })

}]);
//# sourceMappingURL=node_modules_ionic_core_dist_esm_ion-popover_entry_js.js.map